import { describe, test, expect, beforeEach, afterEach } from 'bun:test';
import { existsSync, readFileSync, writeFileSync, rmSync, mkdirSync } from 'node:fs';
import { join } from 'node:path';
import { $ } from 'bun';

const CLI_PATH = join(process.cwd(), 'dist/index.js');
const TEST_OUTPUT_DIR = join(process.cwd(), 'test/output');
const FIXTURES_DIR = join(process.cwd(), 'test/fixtures');

describe('cursor-rules-to-claude CLI', () => {
  beforeEach(() => {
    if (existsSync(TEST_OUTPUT_DIR)) {
      rmSync(TEST_OUTPUT_DIR, { recursive: true });
    }
    mkdirSync(TEST_OUTPUT_DIR, { recursive: true });
  });

  afterEach(() => {
    if (existsSync(TEST_OUTPUT_DIR)) {
      rmSync(TEST_OUTPUT_DIR, { recursive: true });
    }
  });

  test('should display help message', async () => {
    const result = await $`node ${CLI_PATH} --help`.quiet();
    expect(result.exitCode).toBe(0);
    expect(result.stdout.toString()).toContain(
      'Convert Cursor rules to Claude.md format'
    );
    expect(result.stdout.toString()).toContain('--overwrite');
    expect(result.stdout.toString()).toContain('--rules-dir');
    expect(result.stdout.toString()).toContain('--output');
  });

  test('should display version', async () => {
    const result = await $`node ${CLI_PATH} --version`.quiet();
    expect(result.exitCode).toBe(0);
    expect(result.stdout.toString().trim()).toMatch(/^\d+\.\d+\.\d+$/);
  });

  test('should generate CLAUDE.md from test fixtures', async () => {
    const outputFile = join(TEST_OUTPUT_DIR, 'CLAUDE.md');
    const result =
      await $`node ${CLI_PATH} --rules-dir ${FIXTURES_DIR} --output ${outputFile}`.quiet();

    expect(result.exitCode).toBe(0);
    expect(existsSync(outputFile)).toBe(true);

    const content = readFileSync(outputFile, 'utf-8');
    expect(content).toContain(
      '<!-- The following rules are extracted from user-supplied rules files -->'
    );
    expect(content).toContain('<!-- Generated by cursor-rules-to-claude');
    expect(content).toContain('<!-- Auto attached rules -->');
  });

  test('should include alwaysApply:true rules in full', async () => {
    const outputFile = join(TEST_OUTPUT_DIR, 'CLAUDE.md');
    await $`node ${CLI_PATH} --rules-dir ${FIXTURES_DIR} --output ${outputFile}`.quiet();

    const content = readFileSync(outputFile, 'utf-8');
    expect(content).toContain('# Always Apply');
    expect(content).toContain('# Always Applied Rule');
    expect(content).toContain('This rule should be fully included');
    expect(content).toContain('Test point 1');
    expect(content).toContain('const example = "always applied";');
  });

  test('should list alwaysApply:false rules as conditional', async () => {
    const outputFile = join(TEST_OUTPUT_DIR, 'CLAUDE.md');
    await $`node ${CLI_PATH} --rules-dir ${FIXTURES_DIR} --output ${outputFile}`.quiet();

    const content = readFileSync(outputFile, 'utf-8');
    expect(content).toContain('# Agent Requested');
    expect(content).toContain('>Conditional test rule');
    expect(content).toContain('Read the full rule [here]');
    expect(content).not.toContain('Conditional point 1');
  });

  test('should handle files without frontmatter gracefully', async () => {
    const outputFile = join(TEST_OUTPUT_DIR, 'CLAUDE.md');
    const result =
      await $`node ${CLI_PATH} --rules-dir ${FIXTURES_DIR} --output ${outputFile}`.quiet();

    expect(result.exitCode).toBe(0);
    const content = readFileSync(outputFile, 'utf-8');
    expect(content).toContain('# No Frontmatter');
    expect(content).toContain(
      '<!-- The following rules do not have a frontmatter. They are included by default to allow this package to work with multiple different rule types -->'
    );
  });

  test('should overwrite existing CLAUDE.md when --overwrite flag is used', async () => {
    const outputFile = join(TEST_OUTPUT_DIR, 'CLAUDE.md');

    // Create initial file
    writeFileSync(outputFile, '# Existing Content\n\nThis should be overwritten.');

    await $`node ${CLI_PATH} --rules-dir ${FIXTURES_DIR} --output ${outputFile} --overwrite`.quiet();

    const content = readFileSync(outputFile, 'utf-8');
    expect(content).not.toContain('Existing Content');
    expect(content).toContain(
      '<!-- The following rules are extracted from user-supplied rules files -->'
    );
  });

  test('should append to existing CLAUDE.md by default', async () => {
    const outputFile = join(TEST_OUTPUT_DIR, 'CLAUDE.md');

    // Create initial file
    writeFileSync(outputFile, '# Existing Content\n\nThis should be preserved.');

    await $`node ${CLI_PATH} --rules-dir ${FIXTURES_DIR} --output ${outputFile}`.quiet();

    const content = readFileSync(outputFile, 'utf-8');
    expect(content).toContain('Existing Content');
    expect(content).toContain('This should be preserved.');
    expect(content).toContain(
      '<!-- The following rules are extracted from user-supplied rules files -->'
    );
  });

  test("should fail when rules directory doesn't exist", async () => {
    try {
      const result = await $`node ${CLI_PATH} --rules-dir /nonexistent/path`.quiet();
      expect(result.exitCode).toBe(1);
      expect(result.stderr.toString()).toContain('Rules directory not found');
    } catch (error) {
      expect((error as { exitCode: number }).exitCode).toBe(1);
      expect((error as { stderr: { toString(): string } }).stderr.toString()).toContain(
        'Rules directory not found'
      );
    }
  });

  test('should handle empty rules directory', async () => {
    const emptyDir = join(TEST_OUTPUT_DIR, 'empty');
    mkdirSync(emptyDir);

    const result = await $`node ${CLI_PATH} --rules-dir ${emptyDir}`.quiet();
    expect(result.exitCode).toBe(0);
    expect(result.stdout.toString()).toContain('No .md or .mdc files found');
  });

  test('should generate proper rule titles from filenames', async () => {
    const outputFile = join(TEST_OUTPUT_DIR, 'CLAUDE.md');
    await $`node ${CLI_PATH} --rules-dir ${FIXTURES_DIR} --output ${outputFile}`.quiet();

    const content = readFileSync(outputFile, 'utf-8');
    expect(content).toContain('# Agent Requested');
    expect(content).toContain('# Auto Attached');
    expect(content).toContain('# No Frontmatter');
  });

  test('should count rules correctly in output', async () => {
    const result = await $`node ${CLI_PATH} --rules-dir ${FIXTURES_DIR}`.quiet();

    expect(result.stdout.toString()).toMatch(/Generated .* with \d+ rules/);
    expect(result.stdout.toString()).toMatch(/\d+ always applied rules/);
    expect(result.stdout.toString()).toMatch(/\d+ conditional rules/);
  });
});

describe('YAML frontmatter parsing', () => {
  test('should handle invalid YAML gracefully', async () => {
    // Create a temporary directory with only the invalid YAML file
    const tempDir = join(TEST_OUTPUT_DIR, 'temp-invalid');
    mkdirSync(tempDir, { recursive: true });

    const invalidFile = join(tempDir, 'invalid.md');
    writeFileSync(
      invalidFile,
      `---
description: "Test"
globs: "*.ts, *.js"
invalid: [unclosed
---

# Test rule`
    );

    try {
      const result = await $`node ${CLI_PATH} --rules-dir ${tempDir}`.quiet();
      // Should handle the error gracefully (might fail but shouldn't crash)
      expect([0, 1]).toContain(result.exitCode);
    } catch (error) {
      // Should fail gracefully with YAML parsing error
      expect((error as { exitCode: number }).exitCode).toBe(1);
    }
  });

  test('should handle missing description field', async () => {
    const tempDir = join(TEST_OUTPUT_DIR, 'temp-no-desc');
    mkdirSync(tempDir, { recursive: true });

    const testFile = join(tempDir, 'no-desc.md');
    writeFileSync(
      testFile,
      `---
globs: "*.ts"
alwaysApply: false
---

# Rule without description`
    );

    const outputFile = join(TEST_OUTPUT_DIR, 'test-output.md');
    const result =
      await $`node ${CLI_PATH} --rules-dir ${tempDir} --output ${outputFile}`.quiet();

    expect(result.exitCode).toBe(0);
    const content = readFileSync(outputFile, 'utf-8');
    expect(content).toContain('# No Desc');
    expect(content).toContain(
      '<!-- The following rules do not have a frontmatter. They are included by default to allow this package to work with multiple different rule types -->'
    );
  });

  test('should handle missing globs field', async () => {
    const tempDir = join(TEST_OUTPUT_DIR, 'temp-no-globs');
    mkdirSync(tempDir, { recursive: true });

    const testFile = join(tempDir, 'no-globs.md');
    writeFileSync(
      testFile,
      `---
description: "Test rule"
alwaysApply: false
---

# Rule without globs`
    );

    const outputFile = join(TEST_OUTPUT_DIR, 'test-output.md');
    const result =
      await $`node ${CLI_PATH} --rules-dir ${tempDir} --output ${outputFile}`.quiet();

    expect(result.exitCode).toBe(0);
    const content = readFileSync(outputFile, 'utf-8');
    expect(content).toContain('# No Globs');
    expect(content).toContain('>"Test rule"');
    expect(content).toContain('Read the full rule [here]');
  });
});
